// Copyright 2022 Namespace Labs Inc; All rights reserved.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.

package provisioning

import (
	"context"

	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/anypb"
	"namespacelabs.dev/foundation/internal/fnerrors"
	"namespacelabs.dev/foundation/internal/planning/tool/protocol"
	"namespacelabs.dev/foundation/schema"
	"namespacelabs.dev/foundation/std/execution/defs"
)

type StackRequest struct {
	Request
	Env   *schema.Environment
	Focus *schema.Stack_Entry
	Stack *schema.Stack
}

type ApplyOutput struct {
	// Invocations yield serialized invocations.
	Invocations []defs.MakeDefinition
	// A serialized invocation which will be invoked with the result of a computed set of computable values.
	InvocationSources []*schema.SerializedInvocationSource
	// Extensions yield runtime-specific extension, which influence the output of the runtime's deployment.
	Extensions []defs.MakeExtension
	// Computed set of values generated by the tool (e.g. computed ingress).
	Computed []*schema.ComputedConfiguration
	// Extend the server definition.
	ServerExtensions []*schema.ServerExtension
	// Output a resource instance.
	OutputResourceInstance *anypb.Any
	// Set of resources that should be passed to the initializer.
	ComputedResourceInput []ResourceInput
}

type ResourceInput struct {
	Name   string
	Class  *schema.PackageRef
	Intent proto.Message
}

type Compilable interface {
	Compile(StackRequest, *ApplyOutput) error
}

type DeleteOutput struct {
	Invocations []defs.MakeDefinition
}

type StackHandler interface {
	Apply(context.Context, StackRequest, *ApplyOutput) error
	Delete(context.Context, StackRequest, *DeleteOutput) error
}

func parseStackRequest(br Request, header *protocol.StackRelated) (StackRequest, error) {
	if header == nil {
		// This is temporary, while we move from top-level fields to {Apply,Delete} specific ones.
		header = &protocol.StackRelated{
			FocusedServer: br.r.FocusedServer,
			Env:           br.r.Env,
			Stack:         br.r.Stack,
		}
	}

	p := StackRequest{Request: br, Env: header.Env, Stack: header.Stack}

	if header.FocusedServer != "" {
		s := header.Stack.GetServer(schema.PackageName(header.FocusedServer))
		if s == nil {
			return p, fnerrors.InternalError("%s: focused server not present in the stack", header.FocusedServer)
		}

		p.Focus = s
	}

	return p, nil
}
